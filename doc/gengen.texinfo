\input texinfo.tex      @c -*-texinfo-*-*
@c %**start of header
@setfilename gengen.info
@include version.texi
@settitle GNU Gengen @value{VERSION}
@finalout
@c @setchapternewpage odd
@c %**end of header

@set myhomepage @uref{http://www.lorenzobettini.it}

@copying
This manual is for GNU Gengen 
(version @value{VERSION}, @value{UPDATED}).
GNU Gengen (GENerator GENerator), a tool to generate a
C++ class (or C functions) for generating text, based on a template file
with parameters, after substituting some parameters.  This can be used
in code generators.

Copyright @copyright{} 2002--2007 Lorenzo Bettini.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover Texts being ``A GNU Manual,''
and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License.''

(a) The FSF's Back-Cover Text is: ``You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development.''
@end quotation
@end copying

@dircategory GNU programming tools
@direntry
* Gengen: (gengen).         A parameterized-text-generator generator based on a template
@end direntry

@c @shorttitlepage GNU Gengen

@titlepage
@title GNU Gengen
@subtitle A parameterized-text-generator generator based on a template
@subtitle for GNU Gengen version @value{VERSION}
@subtitle updated on @value{UPDATED-MONTH}

@author Lorenzo Bettini, http://www.lorenzobettini.it

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top, Audience, (dir), (dir)
@top GNU Gengen

@insertcopying
@end ifnottex

@menu
* Audience::                    Who this manual is for.
* Copying::                     Your rights.
* Installation::                
* The Problem::                 Generating code may become a pain in the neck.
* The Solution::                Let a tool generate the generator for you.
* Basic Usage in C and C++::    How to run GNU Gengen with C and C++
* Conditionals::                Conditional statements
* Command Options::             Command line options.
* Bugs::                        What is lame and/or buggy in GNU Gengen @value{VERSION}
* Mailing Lists::               
* Index::                       Index.
@end menu

@node Audience, Copying, Top, Top
@unnumbered Audience
@cindex Audience
@cindex Who should use Gengen

GNU Gengen (@emph{GENerator GENerator}) is a tool that, starting from a
parameterized text, called @emph{template}, generates a text generator
that can substitute parameters with values.

This manual is written for C++ and C programmers, specifically the
@emph{lazy} ones ;-).  If you've written any non-trivial code generator,
you probably had to write many @code{cout <<} or @code{printf} lines of
code, mixing fixed text to be generated and parts based on the value of
some variables.   If the text to be generated is full of parts that have
to be substituted at run-time, your code will end up containing many
instructions that print constant strings and variables; this will tend
to make the text to be generated unclear and thus also more difficult to
maintain.   Gengen can save you from this work, leaving you free to
focus on the text that has to be generated.

@cindex parameter
@cindex variable
Indeed the code to be generated will be written in a separated file
(that we call @emph{template} file) that can contain variable parts
(that we call @emph{parameters} or @emph{variables}); Gengen will
generate the generator for you and this generator will also accept the
values that will be substituted in the output.

I started to develop Gengen while maintaining @emph{GNU
Gengetopt}@footnote{@uref{http://www.gnu.org/software/gengetopt}}, since
I had to generate a big amount of code and I found it quite hard to
write code to generate it, since the program ended up being full of many
printf!  That code was unclear and quite hard to maintain.

At the moment Gengen generates C++ or C code; however other target
languages are under development (e.g., Java).

NOTICE: Gengen uses code generated by Gengen itself :-)

@node Copying, Installation, Audience, Top
@unnumbered GNU Gengen Copying Conditions
@cindex Copying conditions
@cindex Conditions for copying GNU Gengen

GNU Gengen is free software; you are free to use, share and modify it
under the terms of the GNU General Public License that accompanies this
manual.

The code that Gengen generates is also free software; however it is
licensed with a simple all-permissive license instead of the GPL or
LGPL.  You are free to do anything you like with the generated code,
including incorporating it into or linking it with proprietary software.

@node Installation, The Problem, Copying, Top
@chapter Installation
@cindex installation
@cindex download

See the file @file{INSTALL} for detailed building and  installation
instructions; anyway if you're used to compiling Linux software that
comes with sources you may simply follow the usual procedure, i.e. untar
the file you downloaded in a directory and then:

@example
cd <source code main directory>
./configure
make
make install
@end example

Note: unless you specify a different install directory by 
@code{--prefix} option of
configure (e.g. @code{./configure --prefix=<your home>}), 
you must be root to run @code{make install}.

Files will be installed in the following directories:

@table @code
@item executables
        @code{/prefix/bin}
@item docs
        @code{/prefix/share/doc/gengen}
@item examples
        @code{/prefix/share/doc/gengen/examples}
@item additional files           
        @code{/prefix/share/gengen}
@end table

Default value for prefix is @code{/usr/local} 
but you may change it with @code{--prefix}
option to configure.

@section Download
@cindex download

You can download it from GNU's ftp site:
@uref{ftp://ftp.gnu.org/gnu/gengen} or from one of its mirrors (see
@uref{http://www.gnu.org/prep/ftp.html}).

I do not distribute Windows binaries anymore; since, they can be easily
built by using Cygnus C/C++ compiler, available at
@uref{http://www.cygwin.com}.  However, if you don't feel like
downloading such compiler, you can request such binaries directly to me,
by e-mail (find my e-mail at my home page) and I can send them to you.

Archives are digitally signed by me (Lorenzo Bettini) with GNU gpg
(@uref{http://www.gnupg.org}). My GPG public key can be found at my home
page (@value{myhomepage}).

You can also get the patches, if they are available for a particular
release (see below for patching from a previous version).

@section Anonymous CVS Access
@cindex CVS

This project's CVS repository can be checked out through anonymous
(pserver) CVS with the following instruction:

@example
cvs -z3 -d:pserver:anonymous@@cvs.savannah.gnu.org:/sources/gengen co gengen
@end example

Further instructions can be found at the address:

@uref{http://savannah.gnu.org/projects/gengen}.

Please notice that this way you will get the latest development sources
of Gengen, which may also be unstable.  This solution is the
best if you intend to correct/extend this program: you should send me
patches against the latest cvs repository sources.

If, on the contrary, you want to get the sources of a given release,
through cvs, say, e.g., version X.Y.Z, you must specify the tag
@code{rel_X_Y_Z} when you run the cvs command or the @code{cvs update}
command.

When you compile the sources that you get through the cvs repository,
before running the @code{configure} and @code{make} commands, you
should, at least the first time, run the command:

@example
sh autogen.sh
@end example

@noindent
This will run the autotools commands in the correct order, and also copy
possibly missing files.  You should have installed recent versions of
@cindex automake
@cindex autoconf
@code{automake} and @code{autoconf} in order for this to succeed.
You will also need @code{flex} and @code{bison}.

Instead of running @code{autogen.sh} another option is to run

@example
autoreconf -i
@end example

@section What you need to build gengen
@cindex requirements

Gengen has been developed under GNU/Linux, using gcc (C++),
and bison (yacc) and flex (lex), and ported under Win32 with Cygnus
C/C++compiler, available at @uref{http://www.cygwin.com}.  I used the
excellent GNU Autoconf and GNU Automake.  I also used Autotools
(@uref{ftp://ftp.ugcs.caltech.edu/pub/elef/autotools}) which creates a
starting source tree (according to GNU standards) with autoconf,
automake starting files.

Finally I used @emph{GNU gengetopt}
(@uref{http://www.gnu.org/software/gengetopt}), for command line parsing.

Actually, you don't need all these tools above to build gengen
because I provide generated sources, unless you want to develop
gengen.

@section Patching from a previous version
@cindex patching

If you downloaded a patch, say
@file{gengen-1.3-1.3.1-patch.gz} (i.e., the patch to go from version
1.3 to version 1.3.1), cd to the directory with sources from the
previous version (gengen-1.3) and type:  

@example
gunzip -cd ../gengen-1.3-1.3.1.patch.gz | patch -p1 
@end example

and restart the compilation process (if you had already run configure a
simple make should do).


@node The Problem, The Solution, Installation, Top
@chapter Generating code or text from within a program
@cindex Generating code with substitutions
@cindex parameter
@cindex template
@pindex cc

Say you are writing a C/C++ program and at some point your program
has to generate the following code:

@example
if (i < 10)
  printf("the value of i is %d", i);
@end example

@noindent It is not so difficult to write this piece of C++ code:

@example
cout << "if (i < 10)" << endl;
cout << "  printf(\"the value of i is %d\", i);" << endl;
@end example

@noindent or the C code:

@example
printf("if (i < 10)\n");
printf("  printf(\"the value of i is %%d\", i);\n");
@end example


@noindent provided that you remember to escape the @code{"} (and in the
C code, also the @code{%}).

Suppose now that the previous piece of code has to be generated many
times by your program, and every time instead of @code{i} another
symbol has to be generated (decided at run time).  In this case,
supposing that this value is contained in a variable @code{symb},
the code for generating this code would be a little bit more
complex:

@example
cout << "if (" << symb << "< 10)" << endl;
cout << "  printf(\"the value of " << symb << " is %d\", "
     << symb << ");" << endl;
@end example

@noindent
And the C version would be even more obfuscated.

Probably you didn't even realize that you forgot to leave
a space before the @code{< 10}; basically this is due to the fact
that this piece of code mixes the code that has to be generated
with the code that generates it, and this tends to make this part
of program less easy to maintain.  Especially if some day you
have to change the code that has to be generated, you'll have
to act on this part of the program, and probably you'll have to
execute some tests in order to be sure that you did it right.

If the code that you have to generate is a slightly more complex,
the task may easily become a pain in the neck!

@node The Solution, Basic Usage in C and C++, The Problem, Top
@chapter How Gengen Can Help You
@cindex Overview of GNU Gengen
@cindex parameter
@pindex gengen
@pindex cc

Wouldn't it be nice if you could write the code to be generated in a
separate file, let's call it @emph{template}, say @file{test1.cc_skel}
this way

@include test1.cc_skel.texinfo

@noindent and have a tool that generates a generator, that you
can instantiate at run-time with the value that has to be substituted to
the @emph{parameter} @code{i}?  If such a tool existed, and it generated
a file @file{test1_c.h} with a C struct @code{test1_gen_struct}, then
you could write simply this code, in another file, say
@file{test1_gen_c.c}:

@include test1_gen_c.c.texinfo

Alternatively, if it generated a file @file{test1.h} with a C++ class
@code{test1_gen_class}, then you could write simply this code, in
another file, say @file{test1_gen.cc}:

@include test1_gen.cc.texinfo

@noindent and when you run it you would obtain the expected output:

@example
if (foo < 10)
  printf("the value of foo is %d", foo);
if (bar < 10)
  printf("the value of bar is %d", bar);
@end example

@noindent Well, Gengen does right this!  Now the code that has to
be generated and the code that generates it are separated and they can
be maintained more easily: if you want to change the code that has to be
generated you act on the file @file{test1.cc_skel}; alternatively, say
you need to change the value that will be substituted for @code{i}, you
just change the file @file{test1_gen.cc} or @file{test1_gen_c.c}.

Notice that the method @code{generate_test1} accepts an output stream
(indeed in this example the standard output stream @code{cout} is used),
thus the stream abstraction facilities can be exploited.  Similarly, the
C function @code{generate_test1} accepts a @code{FILE*}, so you can use
the C file abstraction.

Indeed in order to generate the C++ file @file{test1.h} with the class
@code{test1_gen_class}, I simply had to run the following command:

@example
gengen -i test1.cc_skel --file-name test1.h --gen-name test1
@end example

@noindent
and in order to generate the C file @file{test1_c.h} with the structure
@code{test1_gen_struct}, I simply had to run the following command:

@example
gengen -i test1.cc_skel --file-name test1_c.h --gen-name test1 \
        --output-format=c
@end example

@noindent If I caught your attention and you would like to know
more about these options and more advanced features of Gengen, I
hope you read on :-)

@node Basic Usage in C and C++, Conditionals, The Solution, Top
@chapter Basic Usage in C and C++
@cindex how to use Gengen
@cindex getting started with Gengen
@cindex template
@cindex parameter
@cindex type
@kindex iteration

We've run Gengen, and used it to produce a really spiffy, if rather
pointless, program.  Now we'll go back and look at things in
more detail.

@cindex parameter
@cindex variable
The input file for Gengen is basically any text file, where some parts
are interpreted differently, namely symbols enclosed in @code{@@}.   We
call this input file a @emph{template} and the symbols enclosed in
@code{@@} @emph{parameters} (or @emph{variables}):

@example
This is @@name@@ generated by the program @@progname@@.
The code of @@progname@@ that generated this text was
generated by @@generator@@ version @@version@@, made by
Lorenzo Bettini <foobar@@@@foo.org>.
@end example

@noindent First all notice that, since @code{@@} is a special
character, if you really want it to appear in the generated text you
have to repeated, as in the e-mail address @code{foobar@@@@foo.org}.

If this text is stored in the file @file{example_text.text_skel} and I
process it with the following command:

@example
gengen -i example_text.text_skel 
  --file-name example_text_c.h --gen-name example_text 
  --output_format=c
@end example

@noindent the struct @code{example_text_gen_struct} (option
@code{--gen-name example_text}) will be generated in the file
@file{example_text_c.h} (option @code{--file-name example_text_c.h}).
This struct will have a field for each single parameter, with the same
name of the parameter and type @code{const char *}.   For in instance in
this example it will contain the fields @code{name}, @code{progname},
@code{generator} and @code{version}.   These can be used to set the
string that will be substituted at run-time for the corresponding name
in the input file (Notice that otherwise the empty string is assumed).

Notice that the fields of the structure are not initialized (i.e., they
contain random values) thus we suggest to always initialize the
structure with the following generated function:

@example
void
init_example_text_gen_struct(struct example_text_gen_struct *record);
@end example

Once these values are set, the function

@example
void generate_example_text(FILE *stream, 
        example_text_gen_struct *record, unsigned int indent)
@end example

@noindent can be called in order to generate the text with
substitutions (using the values of the passed struct) into the stream
@code{stream}.  The parameter @code{indent} is useful to specify an
indentation in the generated text.

Alternatively, one can use the following function (even with a non
initiliazed struct) specifying the values for each field (notice the
@code{p} after @code{generate}):

@example
void
generatep_example_text(FILE *stream, unsigned int indent, 
        const char *generator, const char *name, const char *progname, 
        const char *version);
@end example

The following example uses the generated struct in order to
generate the text twice; the second time, the name of the
parameter @code{name} is changed, and the indentation is set to
2@footnote{Notice that the first indentation has to be performed
manually; this behavior is useful in conjunction with a more
involved feature that will be explained later.}:

@include example_text_gen_c.c.texinfo

@noindent The output of this program will be as expected:

@example
This is an example generated by the program example_text_gen.
The code of example_text_gen that generated this text was
generated by Gengen version 1.0, made by
Lorenzo Bettini <foobar@@foo.org>.
 
  This is another example generated by the program example_text_gen.
  The code of example_text_gen that generated this text was
  generated by Gengen version 1.0, made by
  Lorenzo Bettini <foobar@@foo.org>.
@end example

Now, since C lacks the (wonderful :-) stream abstraction that permits
creating a stream that writes into a string (such as the
@code{ostringstream}),  two additional functions are provided in the
generated file, that return a (@code{malloc}ed) string instead of
generating the output to a file (they correspond to the two generate
functions seen above):

@example
char *
genstring_example_text(struct example_text_gen_struct *record, 
        unsigned int indent);

char *
genstringp_example_text(unsigned int indent, 
        const char *generator, const char *name, const char *progname, 
        const char *version);
@end example

@noindent Remember: it is up to you to @code{free} these strings when
you don't need them anymore.

If you prefer to program in C++ you  process the file
@file{example_text.text_skel} with the following command@footnote{Notice
that, by default gengen produces C++ code, so you don't need to specify
the @code{--output-format} option.}:

@example
gengen -i example_text.text_skel 
  --file-name example_text.h --gen-name example_text
@end example

@noindent the class @code{example_text_gen_class} (option
@code{--gen-name example_text}) will be generated in the file
@file{example_text.h} (option @code{--file-name example_text.h}).   This
class will have a member for each single parameter, with the same name
of the parameter and type @code{string}.   This class will also contain
a method @code{set_<xxx>} for each distinct @code{@@xxx@@} present in
the input file; for in instance in this example it will contain the
methods @code{set_name}, @code{set_progname}, @code{set_generator} and
@code{set_version}.   These methods get a @code{const string &} as
parameter.   These can be used to set the string that will be
substituted at run-time for the corresponding name in the input file
(otherwise the empty string is assumed).

Notice that in C++ there's no need to call any initialization function,
since the fields in the class are automatically initialized (as empty
strings) by the constructor.  Morever, there is no version that
generates a string, as in C, since you can use the class
@code{ostringstream}.

Once these values are set, the method

@example
void generate_example_text(ostream &stream, unsigned int indent = 0)
@end example

@noindent can be called in order to generate the text with
substitutions into the stream @code{stream}.  The parameter
@code{indent} (default = 0) is useful to specify an indentation
in the generated text.

The following example uses the generated class in order to
generate the text twice; the second time, the name of the
parameter @code{name} is changed, and the indentation is set to
2@footnote{Notice that the first indentation has to be performed
manually; this behavior is useful in conjunction with a more
involved feature that will be explained later.}:

@include example_text_gen.cc.texinfo

@noindent The output of this program will be as before.

This is already a useful feature of Gengen (at least that's what I think
;-).  However if the text to be generated requires some more
preprocessing, substituting only strings may not be enough.  Instead you
may want the generator to invoke a call back method when it comes to
generate a specific symbol.  This will be explained in the following
section.

@menu
* Callbacks::                   
* Types::                       
@end menu

@node Callbacks, Types, Basic Usage in C and C++, Basic Usage in C and C++
@section Callbacks

You may want the generator to invoke a call back method when it comes to
generate a specific symbol, instead of relying only on strings.  This
can be achieved by specifying the @emph{type} @code{method} for a
parameter.  Let me clarify this with an example.  

Say that your program has to generate some functions, and you,
obviously, want all these functions to have the same definition style;
then you can create a template file @file{example_fundef.cc_skel}:

@include example_fundef.cc_skel.texinfo

@noindent and once again process it with the command

@example
gengen -i example_fundef.cc_skel --file-name example_fundef.h 
  --gen-name example_fundef
@end example

@noindent Then the generated class @code{example_fundef_gen_class}
will  contain  the set-methods @code{set_rettype},   @code{set_funname},
@code{set_paramtype}     and     @code{set_param},   and     a    method
@code{set_funbody},  but  it will  also   declare the following abstract
method:

@example
virtual void
  generate_funbody(ostream &stream, unsigned int indent) = 0;
@end example

Thus, this class cannot be directly instantiated; instead you can derive
from this class and provide the implementation of such method, knowing
that this method will be called right when it comes to generate that
part of code, in case the variable @code{funbody} has not already been
set via the method @code{set_funbody} (indeed the virtual method is
called if @code{funbody} is an empty string).  Here's an example that
extends this class and uses the previous class @code{test1_gen_class} to
generate the function body (file @file{example_fundef_gen.cc}):

@include example_fundef_gen.cc.texinfo

@noindent Notice that the parameter @code{i} of @code{test1_gen_class}
is set to the same name of the inherited field @code{param}: this will
guarantee consistency in the generated code (the code will be
compilable) and the generated function body will use the parameter of
the function definition.  Moreover when the method @code{generate_test1}
is invoked, both the @code{stream} and @code{indent} parameters are
passed over, so that they will be used also by the other generator.

The generated code is once again as expected:

@example
void
foo_fun(unsigned int bar)
@{
  if (bar < 10)
    printf("the value of bar is %d", bar);
@}
@end example

@noindent Notice how the indentation is handled automatically!
Indeed the code generated by Gengen is able to keep track of the
indentation level according to the leading spaces in a line.

This scenario can take place in a code generator where you want to have
all the generated functions with the same style.  When you decide you
want to change the style you'll only have to change the file
@file{example_fundef.cc_skel}, while the other parts of the programs
remain unchanged.

When a generated class contains at least an abstract method, a virtual
destructor is also generated (that basically performs no action) that is
useful if you have to destroy something allocated in the derived class.

The type @code{method} has also an @emph{option}; an option is basically
a statement of the shape @code{<name>=<value>} and has to be specified
between brackets @code{@{@}}.   The option is @code{iteration}.  If one
specified @code{@@funbody:method@{iteration=true@}@@} then no space
would have been generated before invoking the call back method, and no
newline would have been generated after.  This could be useful when the
result of the call back method is either the empty string or a sequence
of similar items; this way if these are handled from within a loop (the
name ``iteration'' comes from this) they can be handled more easily and
uniformly (otherwise you would have to treat the first element and the
last one differently).

If you want to generate C code, you can process it with the command

@example
gengen -i example_fundef.c_skel --file-name example_fundef.h 
  --gen-name example_fundef --output-format c
@end example

@noindent This will generate the file @file{example_fundef.h} containing the
following struct declaration:

@example
struct example_fundef_gen_struct
@{
  const char *funbody;
  const char *funname;
  const char *param;
  const char *paramtype;
  const char *rettype;
@};
@end example

@noindent and some functions 

@example
void generate_example_fundef(FILE *stream,  struct
example_fundef_gen_struct *record, unsigned int indent);
@end example

@noindent that, given an initialized struct, generates the output to
the file @code{stream}, and

@example
void
generatep_example_fundef(FILE *stream, unsigned int indent, 
                         const char *funbody, const char *funname, 
                         const char *param, const char *paramtype,
                         const char *rettype);
@end example

@noindent that does not require a struct, since it requires a value
for each parameter in the template file.

We suggest to use the following function in order to be sure that each
string in the struct is correctly initialized to @code{NULL}:

@example
void
init_example_fundef_gen_struct(struct example_fundef_gen_struct *r);
@end example

@noindent
and two additional functions are provided in the
generated file, that return a (@code{malloc}ed) string instead of
generating the output to a file (they correspond to the two generate
functions seen above):

@example
char *
genstring_example_fundef(struct example_fundef_gen_struct *record,
                         unsigned int indent);

char *
genstringp_example_fundef(unsigned int indent, 
                          const char *funbody, const char *funname,
                          const char *param, const char *paramtype,
                          const char *rettype);
@end example

@noindent Remember: it is up to you to @code{free} these strings when
you don't need them anymore.

As for the type @code{method}, instead of creating a pure virtual
method as in C++, an extern function declaration is generated:

@example
extern
void generate_funbody(FILE *stream,
                      struct example_fundef_gen_struct *record,
                      unsigned int indent);
@end example

@noindent but no code is generated for this function, so that
the programmer is required to provide a definition for this function
somewhere else in the program.   This (extern) function will be called
right when it comes to generate that part of code, in case the argument
@code{funbody} or the field @code{funbody} in the passed struct is
@code{NULL}.

When you use @code{@@if@@} conditionals (or @code{bool} parameters, see
@ref{Types}), the generated record fields are of type @code{short}, and
when you use @code{int} parameters the fields are of type @code{int}.


@menu
* Types::                       Parameter types                     
@end menu

@node Types,  , Callbacks, Basic Usage in C and C++
@section Types

So far, we dealt only with parameters of type @code{method} or string
parameters.  Actually, unless explicitly stated, the type of parameter
is implicitly considered as @code{string} (and for conditional
expressions as @code{bool}, see @ref{Conditionals}).  However, the type
of a parameter can be made explicit, just like we did with @code{method}
type.  In particular, currently, the following basic types are
available: @code{string}, @code{int} and @code{bool}@footnote{This holds
since version 1.0.}.

Since gengen does not provide variable declarations (to keep things
simple :-) you must always specify the type each time (just like for
@code{method} parameters), unless the type is not the default one.  Of
course, gengen will check that you use parameter types consistently,
i.e., always with the same type.

For instance, the following code is correct, since by default the type
of a parameter is of type string, thus the parameter @code{mypar} is
used consistently:

@example
This is the value of the parameter @@mypar@@.
And I repeat it here @@mypar:string@@.
@end example

@noindent
While this example will generate an error, since the first time
@code{mypar} is (implicitly) of type @code{string}, while the second
time is of type @code{int}:

@example
This is the value of the parameter @@mypar@@.
And I repeat it here @@mypar:int@@.
@end example

@noindent
For instance, if this file is called @file{foo.skel}, gengen will issue
the following error:

@example
foo.skel:2: variable "mypar" of type "int"
foo.skel:2: already used with another type
foo.skel:1: previous usage was here with type "string"
@end example

Gengen will use the specified type to generate fields and methods of the
generated class accordintly, e.g., if a parameter is declared of type
@code{int} the generated set method will get an integer parameter.

When generating a parameter of type @code{int} the string representation
of the actual integer value will be output; while for @code{bool}
parameters the literal @code{true} or @code{false} will be output.

@node Conditionals, Command Options, Basic Usage in C and C++, Top
@chapter Conditional statements
@cindex Conditional statements

It is often useful to generate some parts only if specific conditions
are met, and other in the opposite case.  Inside the template file you
can also use the following syntax:

@example
@@if@@ condvar1 @@then@@
text1
@@elseif@@ condvar2 @@then@@
text2
@@elseif@@ ... other alternatives...
@@else@@
text_else
@@endif@@
@end example

@noindent that has the same semantics of if in programming languages you're used to,
and of course all the else parts are optional.  For every
@code{condvar} a boolean instance variable is added to the generated
class, and of course a corresponding set method receiving a boolean
argument.

It is important to notice a possible new line characters and spaces
after a @code{@@then@@}, @code{@@else@@} and @code{@@endif@@}, and
possible spaces before @code{@@if@@}, @code{@@elseif@@} and
@code{@@else@@} are NOT discarded during the generation of code.  Thus,
the following this code

@example
@@if@@ c @@then@@   foo  
@@else@@   bar@@endif@@
@end example

@noindent will generate the following C++ code@footnote{In this section
will use generated C++ code as an example, but of course, the same
features hold for generated C code as well.}

@example
if (c)
  @{
    stream << "   foo";
    stream << "\n";
    stream << indent_str;
  @}
else
  @{
    stream << "   bar";
  @}
@end example

@noindent Notice that there are spaces before the generated
strings, as there were in the template file.

And the following code

@example
  @@if@@ c @@then@@ 
foo
  @@else@@
bar
@@endif@@
@end example

@noindent will generate the following C++ code

@example
stream << "  ";
if (c)
  @{
    stream << "\n";
    stream << indent_str;
    stream << "foo";
    stream << "\n";
    stream << indent_str;
    indent = 2;
    stream << "  ";
  @}
else
  @{
    stream << "\n";
    stream << indent_str;
    stream << "bar";
    stream << "\n";
    stream << indent_str;
  @}
@end example

@noindent Notice the two characters inserted before the
if test (that are generated independently from the evaluation of
@code{c}) and the new line before the then and else bodies.

If you're not confortable with this treatment of spaces and new lines in
conjunction with if statements, you can use the uppercase version of
these keywords, i.e., @code{IF}, @code{THEN}, etc.   When you use these
keywords, spaces and newlines are skipped.   For instance, the previous
example can be rewritten as follows:

@example
@@IF@@ c @@THEN@@   foo  
@@ELSE@@   bar@@ENDIF@@
@end example

@noindent and the generated code will not contain the extra spaces:

@example
if (c)
  @{
    stream << "foo";
    stream << "\n";
    stream << indent_str;
  @}
else
  @{
    stream << "bar";
  @}
@end example

Notice that the space ``eating'' stops at the first newline, thus, the
following code:

@example
@@IF@@ c @@THEN@@
   foo  
@@ELSE@@
   bar
@@ENDIF@@
@end example

@noindent will correctly consider the indentation in the
then and else bodies:

@example
if (c)
  @{
    stream << "   foo";
    stream << "\n";
    stream << indent_str;
  @}
else
  @{
    stream << "   bar";
    stream << "\n";
    stream << indent_str;
  @}
@end example

Finally, you can mix uppercase and lowercase keywords in the same if
statement as you see fit.

Of course, you can nest if inside then branches, else branches, and so
on, just like you do in your programming language:

@example
@@if@@ c1 @@then@@  
@@if@@ c2 @@then@@ foo2
@@elseif@@ c3 @@then@@ foo3
@@endif@@
@@else@@   bar
@@if@@ c4 @@then@@ foo4
@@endif@@
@@endif@@
@end example

@noindent Unfortunately, you cannot indent nested ifs.  Or better, you
can actually, but the indentation characters will be generated in the
code.  If you want to indent the nested ifs you have to use the
uppercase version.

While there is not the concept of ``variable declaration'' in the
template file, Gengen will check that you do use variables in a
consistent way (see @ref{Types}); thus you're not allowed to the same
name for a string variable and for the boolean expression of an if
statement (which is implicitly considered of type @code{bool}).   For
instance, the following code:

@example
@@foo@@

@@if@@ foo @@then@@ @@else@@ bar @@endif@@
@end example

@noindent will generate the following error:

@example
test.h_skel:3: variable "foo" of type "bool"
test.h_skel:3: already used with another type
test.h_skel:1: previous usage was here with type "string"
@end example

@noindent
On the contrary, this version will work fine, since @code{foo} is used
consistently:

@example
@@foo:bool@@

@@if@@ foo @@then@@ @@else@@ bar @@endif@@
@end example

@menu
* Expression syntax::           boolean expression syntax         
@end menu

@node Expression syntax,  , Conditionals, Conditionals
@section Expression syntax

@cindex expression syntax
Since version 1.0, it is possible to specify complex conditional
expressions.  You then can use comparison operators @code{<}, @code{>},
@code{<=}, @code{>=}, @code{=}@footnote{This is the equality operator,
not the assignment operator.} and @code{!=}, and boolean operators
@code{and}, @code{or} and @code{not}.

The precendence of these operators is the standard one, and, of course,
you're allowed to override the precedence by using parenthesis.

Gengen will perform type checking on the expressions (see @ref{Types}),
thus it will check that @code{and}, @code{or} and @code{not} are used
only on boolean expressions, and that when using the other operators,
the operands are of the same type.  Moreover, @code{<}, @code{>},
@code{<=}, @code{>=} cannot be used on boolean expressions.  While they
can be used on string expressions, and in that case the standard
lexicographical order will be used for the comparison.

In expressions you can use constants of the basic types, and in this
case you must not specify the type: it will be automatically inferred.

Any numerical literal will be considered an integer constant; the
literals @code{true} and @code{false} will be considered boolean
constants; finally, string constants must be enclosed in @code{"}.

For instance, the following is a valid expression (notice that, since we
are in the context of an if expression, parameters are automatically
considered of type @code{bool}, thus string parameters must be
explicitly specified with type @code{string}):

@example
@@if@@ (not foo) and (mystring:string < "foo" or i:int > j:int) @@then@@ 
...
@end example

@noindent
Instead, the following one

@example
@@if@@ (not foo) and (mystring < "foo") @@then@@ 
...
@end example

@noindent
will produce the following error:

@example
test.h_skel:1: mystring and "foo" must have the same type
test.h_skel:1: mystring has type bool, "foo" has type string
@end example

@node Command Options, Bugs, Conditionals, Top
@chapter Command line options
@cindex how to use Gengen

These are the options that can be passed to GNU Gengen:

@example
  -h, --help                Print help and exit
  -V, --version             Print version and exit
  -i, --input=file          input file (default std input)
  -F, --file-name=name      name used for generating file (default stdout)
  -f, --gen-name=STRING     prefix for generated code  (default=`gengen')
      --output-format=lang  target language (cpp, c)  (default=`cpp')
      --output-dir=STRING   output directory (default current dir)
      --separate-files      output to separate files (header, source). require 
                              --file-name
      --expand-tabs         strings containing newlines are indented according 
                              to the current indentation level
      --no-gen-version      do not put gengen version in the generated file
      --test-mode           even with errors exit with 0 (this is only for 
                              testing purposes)
      --force               force regeneration of output code
@end example

@noindent Let us examine the ones not yet explained.

@code{--separate-files} that makes Gengen generate the header with
class definition and a @file{.cc} file with the same name specified with
@code{--file-name}, which contains the implementation of the generate
methods.

@code{--expand-tabs} is pretty useful: all the variables specified in
the template files, when generated, will be correctly indented according
to the current indentation level (i.e., the indentation level at the
point where they are in the template file).  Thus, consider a slight
variation of the example seen before:

@example
@@rettype@@
@@funname@@(@@paramtype@@ @@param@@)
@{
  @@funbody@@
@}
@end example

@noindent where @code{funbody} is not of type @code{method}.
Then, if you do not use the @code{--expand-tabs} and you set the string
@verb{"if (bar < 10)\n  return;"}, then the resulting generated code
will look the following one (the other variables are set to values as
seen before):

@example
void
foo_fun(unsigned int bar)
@{
  if (bar < 10)
return;
@}
@end example

@noindent While, if you use @code{--expand-tabs}, the string
containing newlines will be correctly formatted:

@example
void
foo_fun(unsigned int bar)
@{
  if (bar < 10)
    return;
@}
@end example

Gengen, in order to make separate compilation easier and minimize
recompilations of many files, before actually generating the output
file, checks whether a previous generated file exists and, if so,
whether there are any changes since the last generation.  If no
modification is needed, the previous generated file is not overwritten.
This saves compilations, for instance, when you use
@code{--separate-files} and you only change something in the template
file that affects only the code that has to be generated (i.e., the
@code{generate} method itself), but not the class interface.  However,
if you want to force the generation of the output file, you can do so
with the option @code{--force}.

The @code{--output-format} permits generating code different from C++
(in the current version the other available target language is C).

The remaining options should be self-explanatory :-)


@node Bugs, Mailing Lists, Command Options, Top
@chapter Known Bugs, Limitations, and other Misfeatures
@cindex Known Bugs
@cindex Limits
@cindex Misfeatures

No program is perfect, and GNU Gengen is certainly no exception.
A partial list of problems with Gengen @value{VERSION} can
be found in the @file{TODO.txt}.

Should you discover a bug, propose an extension/feature, or just fell
like telling me what you think of this program, please send an e-mail at
the address @code{bug-gengen} at gnu dot org.

@node Mailing Lists, Index, Bugs, Top
@chapter Mailing Lists
@cindex mailing list

The following mailing lists are available: 

@code{help-gengen at gnu dot org}

@noindent
for generic discussions about the program and for asking for help about
it (open mailing list),
@uref{http://mail.gnu.org/mailman/listinfo/help-gengen}
 
@code{info-gengen at gnu dot org}

@noindent
for receiving information about new releases and features (read-only
mailing list),
@uref{http://mail.gnu.org/mailman/listinfo/info-gengen}.
 
If you want to subscribe to a mailing list just go to the URL and follow
the instructions, or send me an e-mail and I'll subscribe you.


@node Index,  , Mailing Lists, Top
@unnumbered Index

@printindex cp

@contents
@bye

